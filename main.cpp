// by arimaqz https://arimaqz.github.io/
#include <windows.h>
#include <iostream>
#include <winternl.h>
typedef NTSTATUS(NTAPI* pNtQueryInformationProcess)(
	HANDLE           ProcessHandle,
	PROCESSINFOCLASS ProcessInformationClass,
	PVOID            ProcessInformation,
	ULONG            ProcessInformationLength,
	PULONG           ReturnLength
	);

typedef struct _CURDIR {
	UNICODE_STRING DosPath;
	HANDLE Handle;
} CURDIR, * PCURDIR;


PPEB getLocalPeb() {
#ifdef _WIN64
	return (PPEB)(__readgsqword(0x60));
#else
	return (PPEB)(__readfsdword(0x30));
#endif
}

PPEB getPebExtended() {
	PROCESS_BASIC_INFORMATION pbi = { 0 };
	PEB peb = { 0 };
	RtlSecureZeroMemory(&peb, sizeof(PEB));
	RtlSecureZeroMemory(&pbi, sizeof(PROCESS_BASIC_INFORMATION));
	pNtQueryInformationProcess ntQueryInformationProcess = (pNtQueryInformationProcess)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryInformationProcess");
	ntQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, &pbi, sizeof(PROCESS_BASIC_INFORMATION), NULL);
	ReadProcessMemory(GetCurrentProcess(), pbi.PebBaseAddress, &peb, sizeof(PEB), NULL); 
	return &peb;
}
DWORD retrieveNumberOfProcesses() {
	PPEB pPeb = getLocalPeb();
	DWORD numberOfProcesses = *(PDWORD)((PBYTE)pPeb + 0x0b8);
	return numberOfProcesses;
}
//`0x0a4`/`0x118`, `0x0a8`/`0x11c` and `0x0ac`/`0x120` 

VOID retrieveOSVersion(OUT PDWORD pMajorVersion, OUT PDWORD pMinorVersion, OUT PDWORD pBuildVersion) {
	PPEB pPeb = getLocalPeb();
#ifdef _WIN64
	*pMajorVersion = *(PDWORD)((PBYTE)pPeb + 0x118);
	*pMinorVersion = *(PDWORD)((PBYTE)pPeb + 0x11c);
	*pBuildVersion = *(PDWORD)((PBYTE)pPeb + 0x120);
#else
	*pMajorVersion = *(PDWORD)((PBYTE)pPeb + 0x0a4);
	*pMinorVersion = *(PDWORD)((PBYTE)pPeb + 0x0a8);
	*pBuildVersion = *(PDWORD)((PBYTE)pPeb + 0x0ac);
#endif
}
BOOL isBeingDebuggedSet() {
	PPEB pPeb = getLocalPeb();
	if (pPeb->BeingDebugged == 1) return true;
}

BOOL isNtGlobalFlagSet() {
	#define FLG_HEAP_ENABLE_TAIL_CHECK 0x10
	#define FLG_HEAP_ENABLE_TREE_CHECK 0x20
	#define FLG_HEAP_VALIDATE_PARAMETERS 0x40
	PPEB pPeb = getLocalPeb();
#ifdef _WIN64
	DWORD ntGlobalFlag = *(PDWORD)((PBYTE)pPeb + 0xBC);
#else 
	DWORD ntGlobalFlag = *(PDWORD)((PBYTE)pPeb + 0x68);
#endif
	if (ntGlobalFlag == FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_TREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS) return true;
}

VOID listAllModules() {
	PPEB pPeb = getLocalPeb();
	PEB_LDR_DATA* pLdr = (PEB_LDR_DATA*)pPeb->Ldr;
	LIST_ENTRY* pModuleList = (LIST_ENTRY*)&pLdr->InMemoryOrderModuleList;
	LIST_ENTRY* pFirstEntry = pModuleList->Flink;
	for (LIST_ENTRY* pListEntry = pFirstEntry; pListEntry != pModuleList; pListEntry = pListEntry->Flink) {
		LDR_DATA_TABLE_ENTRY* pEntry = (LDR_DATA_TABLE_ENTRY*)pListEntry;
		printf("%S\n", pEntry->FullDllName.Buffer);
	}
}

HMODULE customGetModuleHandle(const wchar_t* szDllName) {
	PPEB pPeb = getLocalPeb();
	PEB_LDR_DATA* pLdr = (PEB_LDR_DATA*)pPeb->Ldr;
	LIST_ENTRY* pModuleList = (LIST_ENTRY*)&pLdr->InMemoryOrderModuleList;
	LIST_ENTRY* pFirstEntry = pModuleList->Flink;
	for (LIST_ENTRY* pListEntry = pFirstEntry; pListEntry != pModuleList; pListEntry = pListEntry->Flink) {
		LDR_DATA_TABLE_ENTRY* pEntry = (LDR_DATA_TABLE_ENTRY*)pListEntry;
		if (lstrcmpW(szDllName, pEntry->FullDllName.Buffer) == 0) {
			LIST_ENTRY* pInInitializationOrderLinks = (LIST_ENTRY*)((PBYTE)pEntry + 0x020); //0x020 is offset of InInitializationOrderLinks
			return (HMODULE)pInInitializationOrderLinks->Flink;
			//return (HMODULE)pEntry->Reserved2[0]
		}
	}
}


VOID spoofLocal() {
	PPEB pPeb = getLocalPeb();
	const wchar_t spoof[] = L"C:\\Windows\\System32\\notepad.exe";
	const wchar_t spoofDir[] = L"C:\\Windows\\System32";
	USHORT spoodSize = wcslen(spoof) * sizeof(wchar_t);
	USHORT spoodDirSize = wcslen(spoofDir) * sizeof(wchar_t);
	pPeb->ProcessParameters->CommandLine.Buffer = (PWSTR)spoof;
	pPeb->ProcessParameters->CommandLine.Length = spoodSize;
	pPeb->ProcessParameters->ImagePathName.Buffer = (PWSTR)spoof;
	pPeb->ProcessParameters->ImagePathName.Length = spoodSize;
	PCURDIR pCurDir = (PCURDIR)((PBYTE)pPeb->ProcessParameters + 0x038);
	pCurDir->DosPath.Buffer = (PWSTR)spoofDir;
	pCurDir->DosPath.Length = spoodDirSize;
}

VOID spoofRemote() {
	//PPID spoofing
	SIZE_T sAttrList = NULL;
	STARTUPINFOEXA siEx = { 0 };
	PROCESS_INFORMATION pi = { 0 };
	RtlSecureZeroMemory(&siEx, sizeof(STARTUPINFOEXA));
	RtlSecureZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
	siEx.StartupInfo.cb = sizeof(STARTUPINFOEXA);
	HANDLE hParentProcess = OpenProcess(MAXIMUM_ALLOWED, FALSE, <pid>);
	InitializeProcThreadAttributeList(NULL, 1, NULL, &sAttrList);
	siEx.lpAttributeList = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sAttrList);
	InitializeProcThreadAttributeList(siEx.lpAttributeList, 1, NULL, &sAttrList);
	UpdateProcThreadAttribute(siEx.lpAttributeList, NULL, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hParentProcess, sizeof(HANDLE), NULL, NULL);
	CreateProcessA(NULL, (LPSTR)"C:\\windows\\system32\\notepad.exe", NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, &siEx.StartupInfo, &pi);

	// manipulate PEB
	PPEB pPeb = getPebExtended();

	const wchar_t spoof[] = L"C:\\Windows\\System32\\calc.exe";
	const wchar_t spoofDir[] = L"C:\\Windows\\System32	";
	USHORT spoodSize = wcslen(spoof) * sizeof(wchar_t);
	USHORT spoodDirSize = wcslen(spoofDir) * sizeof(wchar_t);
	//we have to store 'spoof' in target process address space to be able to use it
	LPVOID remoteCommandLine = VirtualAllocEx(pi.hProcess, NULL, spoodSize, MEM_COMMIT, PAGE_READWRITE);
	WriteProcessMemory(pi.hProcess, remoteCommandLine, spoof, spoodSize, NULL);
	WriteProcessMemory(pi.hProcess, (char*)pPeb->ProcessParameters + offsetof(RTL_USER_PROCESS_PARAMETERS, CommandLine.Buffer), &remoteCommandLine, sizeof(LPVOID), NULL);
	WriteProcessMemory(pi.hProcess, (char*)pPeb->ProcessParameters + offsetof(RTL_USER_PROCESS_PARAMETERS, ImagePathName.Buffer), &remoteCommandLine, sizeof(LPVOID), NULL);

	LPVOID remoteCurrentDirectory = VirtualAllocEx(pi.hProcess, NULL, spoodDirSize, MEM_COMMIT, PAGE_READWRITE);
	WriteProcessMemory(pi.hProcess, remoteCurrentDirectory, spoofDir, spoodDirSize, NULL);
	PCURDIR pCurDir = (PCURDIR)((PBYTE)pPeb->ProcessParameters + 0x038);
	WriteProcessMemory(pi.hProcess, (char*)pCurDir + offsetof(CURDIR, DosPath.Buffer), &remoteCurrentDirectory, sizeof(LPVOID), NULL);

}
